=Deployment=

Add `hibernate-audit.jar` in your Hibernate application classpath. You can get the jar file from the hibernate-audit maven repository located here: http://hibernate-audit.googlecode.com/svn/repository/releases

=Activation=

Register {{{com.googlecode.hibernate.audit.listener.AuditListener}}} as a listerner to your session factory for the following events:

    * post-insert
    * post-update
    * post-delete
    * pre-collection-update
    * pre-collection-remove
    * post-collection-recreate

*Hibernate configuration
{{{
...
<hibernate-configuration>
    <session-factory>
....

        <listener class="com.googlecode.hibernate.audit.listener.AuditListener"  type="post-insert"/>
        <listener class="com.googlecode.hibernate.audit.listener.AuditListener"  type="post-update"/>
        <listener class="com.googlecode.hibernate.audit.listener.AuditListener"  type="post-delete"/>
        <listener class="com.googlecode.hibernate.audit.listener.AuditListener"  type="pre-collection-update"/>
        <listener class="com.googlecode.hibernate.audit.listener.AuditListener"  type="pre-collection-remove"/>
        <listener class="com.googlecode.hibernate.audit.listener.AuditListener"  type="post-collection-recreate"/>
    </session-factory>
</hibernate-configuration>
}}}

*Spring LocalSessionFactoryBean
{{{
     ....

    <bean id="com.googlecode.hibernate.audit.listener.AuditListener" class="com.googlecode.hibernate.audit.listener.AuditListener" scope="singleton"/>

     <bean id="mySessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean">

       ... application specific session factory properties......

       <property name="eventListeners">
            <map>
                <entry key="post-insert">
                    <list>
                        <ref local="com.googlecode.hibernate.audit.listener.AuditListener" />
                    </list>
                </entry>
                <entry key="post-update">
                    <list>
                        <ref local="com.googlecode.hibernate.audit.listener.AuditListener" />
                    </list>
                </entry>
                <entry key="post-delete">
                    <list>
                        <ref local="com.googlecode.hibernate.audit.listener.AuditListener" />
                    </list>
                </entry>
                <entry key="pre-collection-update">
                    <list>
                        <ref local="com.googlecode.hibernate.audit.listener.AuditListener" />
                    </list>
                </entry>
                <entry key="pre-collection-remove">
                    <list>
                        <ref local="com.googlecode.hibernate.audit.listener.AuditListener" />
                    </list>
                </entry>
                <entry key="post-collection-recreate">
                    <list>
                        <ref local="com.googlecode.hibernate.audit.listener.AuditListener" />
                    </list>
                </entry>
              </map>
        </property>
    </bean>
}}}

=HBA-Specific Properties=

===`hba.configuration.observer.clazz`===

`hba.configuration.observer.clazz` specifies application specific implementation of {{{com.googlecode.hibernate.audit.configuration.AuditConfigurationObserver}}} interface.

{{{
hba.configuration.observer.clazz=com.myapp.MyAppAuditSessionFactoryObserver
}}}

Using a custom `AuditConfigurationObserver` the application can specify application specific implementation that controls all extensions. The {{{AuditConfigurationObserver.auditConfigurationCreated}}} method will be invoked at the end of the `SessionFactory` initialization process - see [http://www.hibernate.org/hib_docs/v3/api/org/hibernate/event/Initializable.html#initialize(org.hibernate.cfg.Configuration) Initializable.initialize(org.hibernate.cfg.Configuration)]
 
===`hba.audited-model.dynamic-update`===

`hba.audited-model.dynamic-update` controll whether the audit framework will set the dynamic-update for every audited entity to true - Note that this property have effect only when its value is true. Using the property set to true will guarantee that the audit will capture all updates that happend for the audited domain (this statement does not include explicitly not audited entities/properties which are always excluded from the audit) - enabling this will cause some performance penalties because Hibernate will not use a single update statement for a particular entity type but it will use dynamic update statement that will be generated on the fly based on which entity properties were modified. For more information check the [http://www.hibernate.org Hibernate site]

{{{
hba.audited-model.dynamic-update=true
}}}

===`hba.mappingfile`===

`hba.mappingfile` if set this specified the HBM location for the hibernate entities configuration. This is useful only when the application want to specify a different mapping from the one that is provided with the audit framework. For example the application can change table names, column names and etc. You can use the HBM file provided in the JAR file as a template and modify it according to your needs. Hibernate audit does not use hibernate annotations so you can control all mapping information from the HBM file only.

=Application Extensions=

===`AuditableInformationProvider`===

Hibernate audit framework will use this provider to determine if a particular entity or entity/property needs to be audited. By default all entities and entity/properties are audited except for the hibernate audit entities - also you can't override this behaviour because it prevents infinite loop.

===`ConcurrentModificationProvider`===

===`PropertyValueConverter`===

Whenever a value that is not entity or component needs to be stored in the audit tables then the audit will invoke this converter to convert object value into String. 

===`AuditLogicalGroupProvider`===

===`SecurityInformationProvider`===

===`TransactionSyncronization`===

Hibernate audit will delegate the transaction synchronization registration to this provider. The default implementation uses 

{{{
eventSource.getTransaction().registerSynchronization(synchronization);
}}}

<b>NOTE:</b> If you are using automatic Hibernate session management (e.g. you do not explicitly have session.close() method calls in your code - for example when you are using software like Spring) that closes the session before all transaction sychronization hooks receive the beforeCompletion notification then you MUST provide a custom hibernate-audit TransactionSynchronization that will make sure that the audit synchronziation hook is called before the session is closed. 

For example if you are using Spring then in this implementation you should use 
{{{
org.springframework.transaction.support.TransactionSynchronizationManager.registerSynchronization(springSyncronization)
}}}

Where the springSynchronization should be a wrapper of the synchrozation parameter but will also provide order (e.g. the wrapper class should also implement {{{{org.springframework.core.Ordered}}} Spring interface)

===`AuditTransactionAttributeProvider`===

Provides collection of entities that can be stored and associated to the current audit transaction. The hibernate audit will call the provider to get the list of entites that need to be persisted as part of the audit transaction. Default provider returns {{{null}} so no audit transaction attributes will be stored in the audit tables.

=Error Handling=

All exceptions are logged. You need to setup correctly the Log4j library before you can see those log messages. All Hibernate Audit log categories starts with 
{{{com.googlecode.hibernate.audit}}}

*Note:* [http://www.hibernate.org Hibernate] and [http://www.springframework.org Spring Framework] will notify all {{{javax.transaction.Synchronization}}} for before and after completion in {{{try/catch}}} block that swallows {{{java.lang.Throwable}}} and only logging then in ERROR level. This means that if the Hibernate Audit synchronization throws an exception then this exception won't be propagated to the client - the only thing that the Hibernate Audit framework can do when such exception occurs is to try to mark the current transaction for rollback. If you are using Log4j as your logging framework then you can fix this problem using the following workaround: Create a new class that you can invoke after the Log4j is initialized and add Log4j special appenders for both Hibernate and Spring loggers (assuming that you do have both frameworks)

{{{
import org.apache.log4j.AppenderSkeleton;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.spi.LoggingEvent;
import org.hibernate.transaction.JDBCTransaction;
import org.springframework.transaction.support.TransactionSynchronizationUtils;

/**
 * @author <a href="mailto:kchobantonov@yahoo.com">Krasimir Chobantonov</a>
 */
public final class AuditExceptionPropagation {

    private static final Logger HIBERNATE_TRANSACTION_LOG = Logger.getLogger(JDBCTransaction.class);
    private static final Logger SPRING_TRANSACTION_LOG = Logger.getLogger(TransactionSynchronizationUtils.class);

    public void init() {
        interceptLog(HIBERNATE_TRANSACTION_LOG);
        interceptLog(SPRING_TRANSACTION_LOG);
    }

    private void interceptLog(Logger logger) {
        if (Level.OFF.equals(logger.getLevel())) {
            logger.setLevel(Level.ERROR);
        }

        logger.addAppender(new AppenderSkeleton() {

            @Override
            public boolean requiresLayout() {
                return false;
            }

            @Override
            public void close() {
            }

            @Override
            protected void append(LoggingEvent event) {
                if (event.getThrowableInformation() != null && event.getThrowableInformation().getThrowable() instanceof RuntimeException) {
                    throw (RuntimeException) event.getThrowableInformation().getThrowable();
                }
            }
        });
    }

}
}}}


This implementation will re-throw any RuntimeException when the ThrowableInformation is provided (make sure that you do not have custom Log4j exception handling that will remove this information from the {{{LoggginEvent}}}.

=Known Limitations and Workarounds=

  * Hibernate Audit framework currently does not capture {{{java.util.Map}}} entity persistence attributes.
    # Currently there is no workaround solution without modifying the Hibernate Audit framework
  * Hibernate Audit framework currently does not support entity/component attribute values (that are not references to entity or component or collection of such) for which the {{{java.lang.String}}} representation is greater than 4000 chars (all entities and componenets are supported). All such properties must not be marked as auditted because of potential RuntimeExceptions that may be raise during the save to the database.
    # There is a workaround for this without modifying the Hibernate Audit library. You need override the Hibernate Audit entity mapping document and to change the type of the {{{ATTRIBUTE_VALUE_TXT}}} column from {{{VARCHAR(4000)}}} to CLOB and also to use custom {{{UserType}}} - {{{org.hibernate.type.StringClobType}}}, then you need to make sure that you are using this new mapping file by using the {{{hba.mappingfile}}} property. You also need to provide the a custom implementation of {{{com.googlecode.hibernate.audit.extension.event.AuditLogicalGroupProvider}}} and register that approperiately with the Hiberate Audit framework if your entity property type can't be converted properly to java.lang.String - for example {{{java.io.InputStream}}} and etc. *Note:* This workaround has disadvantages - the performance will not be very good compared to the original implementation.

