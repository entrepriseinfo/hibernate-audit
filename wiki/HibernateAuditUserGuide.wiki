=Deployment=

Add `hibernate-audit.jar` in your Hibernate application classpath. You can get the jar file from the hibernate-audit maven repository located here: http://hibernate-audit.googlecode.com/svn/repository/releases

=Activation=

Register {{{com.googlecode.hibernate.audit.listener.AuditListener}}} as a listerner to your session factory for the following events:

    * post-insert
    * post-update
    * post-delete
    * pre-collection-update
    * pre-collection-remove
    * post-collection-recreate

*Hibernate configuration
{{{
...
<hibernate-configuration>
    <session-factory>
....

        <listener class="com.googlecode.hibernate.audit.listener.AuditListener"  type="post-insert"/>
        <listener class="com.googlecode.hibernate.audit.listener.AuditListener"  type="post-update"/>
        <listener class="com.googlecode.hibernate.audit.listener.AuditListener"  type="post-delete"/>
        <listener class="com.googlecode.hibernate.audit.listener.AuditListener"  type="pre-collection-update"/>
        <listener class="com.googlecode.hibernate.audit.listener.AuditListener"  type="pre-collection-remove"/>
        <listener class="com.googlecode.hibernate.audit.listener.AuditListener"  type="post-collection-recreate"/>
    </session-factory>
</hibernate-configuration>
}}}

*Spring LocalSessionFactoryBean
{{{
     ....

    <bean id="com.googlecode.hibernate.audit.listener.AuditListener" class="com.googlecode.hibernate.audit.listener.AuditListener" scope="singleton"/>

     <bean id="mySessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean">

       ... application specific session factory properties......

       <property name="eventListeners">
            <map>
                <entry key="post-insert">
                    <list>
                        <ref local="com.googlecode.hibernate.audit.listener.AuditListener" />
                    </list>
                </entry>
                <entry key="post-update">
                    <list>
                        <ref local="com.googlecode.hibernate.audit.listener.AuditListener" />
                    </list>
                </entry>
                <entry key="post-delete">
                    <list>
                        <ref local="com.googlecode.hibernate.audit.listener.AuditListener" />
                    </list>
                </entry>
                <entry key="pre-collection-update">
                    <list>
                        <ref local="com.googlecode.hibernate.audit.listener.AuditListener" />
                    </list>
                </entry>
                <entry key="pre-collection-remove">
                    <list>
                        <ref local="com.googlecode.hibernate.audit.listener.AuditListener" />
                    </list>
                </entry>
                <entry key="post-collection-recreate">
                    <list>
                        <ref local="com.googlecode.hibernate.audit.listener.AuditListener" />
                    </list>
                </entry>
              </map>
        </property>
    </bean>
}}}

=HBA-Specific Properties=

===`hba.configuration.observer.clazz`===

`hba.configuration.observer.clazz` specifies application specific implementation of {{{com.googlecode.hibernate.audit.configuration.AuditConfigurationObserver}}} interface.

{{{
hba.configuration.observer.clazz=com.myapp.MyAppAuditSessionFactoryObserver
}}}

Using a custom `AuditConfigurationObserver` the application can specify application specific implementation that controls all extensions. The {{{AuditConfigurationObserver.auditConfigurationCreated}}} method will be invoked at the end of the `SessionFactory` initialization process - see [http://www.hibernate.org/hib_docs/v3/api/org/hibernate/event/Initializable.html#initialize(org.hibernate.cfg.Configuration) Initializable.initialize(org.hibernate.cfg.Configuration)]
 
===`hba.audited-model.dynamic-update`===

`hba.audited-model.dynamic-update` controll whether the audit framework will set the dynamic-update for every audited entity to true - Note that this property have effect only when its value is true. Using the property set to true will guarantee that the audit will capture all updates that happend for the audited domain (this statement does not include explicitly not audited entities/properties which are always excluded from the audit) - enabling this will cause some performance penalties because Hibernate will not use a single update statement for a particular entity type but it will use dynamic update statement that will be generated on the fly based on which entity properties were modified. For more information check the [http://www.hibernate.org Hibernate site]

{{{
hba.audited-model.dynamic-update=true
}}}

===`hba.mappingfile`===

`hba.mappingfile` if set this specified the HBM location for the hibernate entities configuration. This is useful only when the application want to specify a different mapping from the one that is provided with the audit framework. For example the application can change table names, column names and etc. You can use the HBM file provided in the JAR file as a template and modify it according to your needs. Hibernate audit does not use hibernate annotations so you can control all mapping information from the HBM file only.

=Application Extensions=

===`AuditableInformationProvider`===

Hibernate audit framework will use this provider to determine if a particular entity or entity/property needs to be audited. By default all entities and entity/properties are audited except for the hibernate audit entities - also you can't override this behaviour because it prevents infinite loop.

===`ConcurrentModificationProvider`===

===`PropertyValueConverter`===

Whenever a value that is not entity or component needs to be stored in the audit tables then the audit will invoke this converter to convert object value into String. 

===`AuditLogicalGroupProvider`===

===`SecurityInformationProvider`===

===`TransactionSyncronization`===

Hibernate audit will delegate the transaction synchronization registration to this provider. The default implementation uses 

{{{
eventSource.getTransaction().registerSynchronization(synchronization);
}}}

<b>NOTE:</b> If you are using automatic Hibernate session management (e.g. you do not explicitly have session.close() method calls in your code - for example when you are using software like Spring) that closes the session before all transaction sychronization hooks receive the beforeCompletion notification then you MUST provide a custom hibernate-audit TransactionSynchronization that will make sure that the audit synchronziation hook is called before the session is closed. 

For example if you are using Spring then in this implementation you should use 
{{{
org.springframework.transaction.support.TransactionSynchronizationManager.registerSynchronization(springSyncronization)
}}}

Where the springSynchronization should be a wrapper of the synchrozation parameter but will also provide order (e.g. the wrapper class should also implement {{{{org.springframework.core.Ordered}}} Spring interface)

===`AuditTransactionAttributeProvider`===

Provides collection of entities that can be stored and associated to the current audit transaction. The hibernate audit will call the provider to get the list of entites that need to be persisted as part of the audit transaction. Default provider returns {{{null}} so no audit transaction attributes will be stored in the audit tables.

=Error Handling=