package com.googlecode.hibernate.audit;

import org.apache.log4j.Logger;
import org.hibernate.SessionFactory;
import org.hibernate.cfg.Settings;
import org.hibernate.impl.SessionFactoryImpl;
import com.googlecode.hibernate.audit.model.AuditTransaction;
import com.googlecode.hibernate.audit.model.Manager;
import com.googlecode.hibernate.audit.model.LogicalGroupIdProvider;

import java.util.List;
import java.util.ArrayList;
import java.util.Collections;
import java.io.Serializable;

/**
 * The main programmatic entry point. This class allows turning audit on/off at runtime, and various
 * other configuration options.
 *
 * @author <a href="mailto:ovidiu@feodorov.com">Ovidiu Feodorov</a>
 *
 * Copyright 2008 Ovidiu Feodorov
 *
 * @version <tt>$Revision$</tt>
 *
 * $Id$
 */
public final class HibernateAudit
{
    // Constants -----------------------------------------------------------------------------------

    private static final Logger log = Logger.getLogger(HibernateAudit.class);

    // Static --------------------------------------------------------------------------------------

    private static Manager manager;
    private static Object lock = new Object();

    /**
     * Enable audit on specified session factory, by dynamically registering listeners that
     * capture and record state changes on transactional commits. In order to disable audit on the
     * session, use HibernateAudit.disable(SessionFactory).
     *
     * Note: The persistence events generated by sessions created by this auditedSessionFactory
     *       won't be associated with any applicaton level logical group. If you need logical group
     *       information in the database, use enable(SessionFactory, LogicalGroupIdProvider).
     *
     * @see HibernateAudit#disable(SessionFactory)
     * @see HibernateAudit#enable(SessionFactory, LogicalGroupIdProvider)
     *
     * @param auditedSessionFactory - the session factory of the audited persistence unit.
     */
    public static void enable(SessionFactory auditedSessionFactory) throws Exception
    {
        enable(auditedSessionFactory, null);
    }

    /**
     * Enable audit on specified session factory, by dynamically registering listeners that
     * capture and record state changes on transactional commits. In order to disable audit on the
     * session, use HibernateAudit.disable(SessionFactory).
     *
     * @see HibernateAudit#disable(SessionFactory)
     *
     * @param auditedSessionFactory - the session factory of the audited persistence unit.
     * @param lgip - the application-level LogicalGroupIdProvider. If null, no logical group id
     *        will persisted in the database. This is alright if you don't need logical grouping
     *        of entities.
     */
    public static void enable(SessionFactory auditedSessionFactory, LogicalGroupIdProvider lgip)
        throws Exception
    {
        if (!(auditedSessionFactory instanceof SessionFactoryImpl))
        {
            throw new IllegalArgumentException(
                "cannot enable audit unless given session factory is a SessionFactoryImpl " +
                "instance; instead we got " +
                (auditedSessionFactory == null ? null : auditedSessionFactory.getClass().getName()));
        }

        SessionFactoryImpl sfi = (SessionFactoryImpl)auditedSessionFactory;

        synchronized(lock)
        {
            if (manager == null)
            {
                Settings settings = sfi.getSettings();
                manager = new Manager(settings);
                manager.start();
            }
        }

        manager.register(sfi, lgip);

        log.debug("audit enabled on " + sfi);
    }

    /**
     * @return true if audit manager is started, false otherwise.
     */
    public static boolean isStarted()
    {
        synchronized(lock)
        {
            return manager != null && manager.isStarted();
        }
    }

    /**
     * @return true if audit is enabled on the specified session factory instance, false otherwise.
     */
    public static boolean isEnabled(SessionFactory auditedSessionFactory)
    {
        if (!(auditedSessionFactory instanceof SessionFactoryImpl))
        {
            return false;
        }

        SessionFactoryImpl sfi = (SessionFactoryImpl)auditedSessionFactory;

        synchronized(lock)
        {
            return manager != null && manager.isRegistered(sfi);
        }
    }

    /**
     * Turns audit off on the specified session factory. If this is the last active factory
     * associated with the audit manager, the manager itself is stopped and all audit resources are
     * freed.
     *
     * @return true if audit is turned off on the specified session factory, or false if there was
     *         no active audit runtime to disable.
     */
    public static boolean disable(SessionFactory sf) throws Exception
    {
        synchronized(lock)
        {
            if (manager == null)
            {
                return false;
            }

            try
            {
                return manager.unregister(sf);
            }
            finally
            {
                if (manager.getAuditedSessionFactories().isEmpty())
                {
                    manager.stop();
                    manager = null;
                }
            }
        }
    }

    /**
     * Turns audit off on all registered session factories and stops the audit manager, freeing all
     * audit resources.
     *
     * @return true if audit was turned off on at least one session factory, or false if there was
     *         no active audit runtime to disable.
     */
    public static boolean disableAll() throws Exception
    {
        synchronized(lock)
        {
            if (manager == null)
            {
                return false;
            }

            boolean result = false;

            for(SessionFactoryImpl s: manager.getAuditedSessionFactories())
            {
                result |= disable(s);
            }

            return result;
        }
    }

    // Queries -------------------------------------------------------------------------------------

    /**
     * A general purpose query facility. Understands HQL.
     */
    public static List query(String query, Object... args) throws Exception
    {
        Manager m = null;

        synchronized(lock)
        {
            if (manager == null)
            {
                throw new IllegalStateException("audit runtime not enabled");
            }

            m = manager;
        }

        return m.query(query, args);
    }

    /**
     * Specialized query.
     *
     * TODO add tests.
     *
     * @param entityId - if null, returns all transactions. This may be a very costly operation.
     *
     * @return the list of transactions that have been applied to the entity with the specified id.
     */
    public static List<AuditTransaction> getTransactions(Serializable entityId) throws Exception
    {
        List result = null;
        if (entityId == null)
        {
            String qs = "from AuditTransaction";
            result = query(qs);
        }
        else
        {
            String qs =
                "from AuditTransaction as t, AuditEvent as e " +
                "where e.transaction = t and e.targetId = :entityId";
            result = query(qs, entityId);
        }

        if (result.size() == 0)
        {
            return Collections.emptyList();
        }

        List<AuditTransaction> ts = new ArrayList<AuditTransaction>();
        for(Object o: result)
        {
            AuditTransaction at =
                entityId == null ? (AuditTransaction)o : (AuditTransaction)((Object[])o)[0];
            
            if (!ts.contains(at))
            {
                ts.add(at);
            }
        }

        return ts;
    }

    /**
     * Specialized query.
     *
     * TODO add tests.
     *
     * @return the list of transactions that have been applied to entities belonging to the
     *         specified logical group.
     */
    public static List<AuditTransaction> getTransactionsByLogicalGroup(Serializable lgId)
        throws Exception
    {
        String qs = "from AuditTransaction as t where t.logicalGroupId = :lgId";
        return query(qs, lgId);
    }

    // Delta functions -----------------------------------------------------------------------------

    /**
     * @param base - the intial state of the object to apply transactional delta to.
     */
    public static void delta(Object base, Long txId) throws Exception
    {
        delta(base, null, txId);
    }

    /**
     * @param base - the intial state of the object to apply transactional delta to.
     */
    public static void delta(Object base, Serializable id, Long txId) throws Exception
    {
        delta(base, null, id, txId);
    }

    /**
     * @param base - the intial state of the object to apply transactional delta to.
     * @param entityName - the entityName corresponding to the base instance. If null, base's class
     *        will be used.
     */
    public static void delta(Object base, String entityName, Serializable id, Long txId)
        throws Exception
    {
        Manager m = null;

        synchronized(lock)
        {
            if (manager == null)
            {
                throw new IllegalStateException("audit runtime not enabled");
            }

            m = manager;
        }

        m.delta(base, entityName, id, txId);
    }

    /**
     * TODO added in a haste, review
     */
    public static List<Temp> getDelta(Long txId) throws Exception
    {
        // TODO duplicate code with delta()
        Manager m = null;

        synchronized(lock)
        {
            if (manager == null)
            {
                throw new IllegalStateException("audit runtime not enabled");
            }

            m = manager;
        }

        return m.getDelta(txId);
    }

    // Others --------------------------------------------------------------------------------------

    /**
     * Exposing the manager to the inner packages, until I refactor and I unify package protected
     * access.
     */
    public static Manager getManager()
    {
        return manager;
    }

    // Attributes ----------------------------------------------------------------------------------

    // Constructors --------------------------------------------------------------------------------

    // Public --------------------------------------------------------------------------------------

    @Override
    public String toString()
    {
        return "HibernateAudit[" + Integer.toHexString(System.identityHashCode(this)) + "]";
    }

    // Package protected ---------------------------------------------------------------------------

    // Protected -----------------------------------------------------------------------------------

    // Private -------------------------------------------------------------------------------------

    // Inner classes -------------------------------------------------------------------------------
}
